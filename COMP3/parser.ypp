%{
	#include <iostream>
	#include <string>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"
	#include "asm.hpp"
	#include <sstream>


	using namespace std;
	using namespace output;

#define BYTE_MAX_SIZE 255
#define ARRAY_MIN_SIZE 1
#define YYERROR_VERBOSE 1
#define YYDEBUG 1 

	stack<Table*> tableStack;
	FuncTable* funcTable;
	stack<int> offsetStack;

	void make_table();
	bool is_break_scope();
	bool check_var_exists_id(string id, Node** retNode);
	void open_new_scope(bool is_break_allowed);
	void open_new_function_scope(Type_enum retType);
	bool check_func_exists(string& id, Node* expListNode, Type_enum **retType);
	void close_scope();
	bool check_func_exists_name(string id);
	bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray, int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize);
	bool isAssignable(Node* assignedTo, Node* assigned);


%}

%start S
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%nonassoc IF
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOP
%token ID
%token NUM
%token STRING
%nonassoc  ELSE
%token EOF1

%%

S			:	Program EOF1 {
															if (!check_func_exists_name("main"))
															{
																errorMainMissing();
																exit(0);
															}

															FuncTableEntry* func;

															for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
															{
																if ((*it)->id == "main" )
																{
																	func = (*it);
																	break;
																}
																
															}
															
															if (func->nodeList.size() != 0)
															{
																errorMainMissing();
																exit(0);
															}

															if (OUR_VOID != func->retType)
															{
																errorMainMissing();
																exit(0);
															}

															/*print*/
															endScope();
															tableStack.top()->print_scope();
															tableStack.pop();
															offsetStack.pop();
														}
			;

Program		: { make_table(); }	Funcs					
			;

Funcs		:
			|	FuncDecl Funcs
			;

FuncDecl	:	RetType ID LPAREN Formals RPAREN		{
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															FuncTable *f_table = dynamic_cast<FuncTable*>(tableStack.top());
															Type_enum retType = $1->type;
															FuncTableEntry *func_entry = new FuncTableEntry($2->id, retType, $4->frmlList);
															f_table->push(func_entry);
															open_new_function_scope($1->type);
															int param_offset = 0;
															for (vector<Node*>::iterator it = $4->frmlList.begin();it != $4->frmlList.end(); it++)
															{
																VarTableEntry *var_entry;
																Node* temp;
																Node* frml = (*it);
																if (check_var_exists_id(frml->id, &temp) || check_func_exists_name(frml->id))
																{
																	errorDef(yylineno, frml->id);
																	exit(0);
																}
																if (frml->isArray)
																{
																	param_offset -= frml->arraySize;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																else {
																	param_offset--;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																dynamic_cast<VarTable*>(tableStack.top())->push(var_entry);

															}
														} LBRACE Statements RBRACE {
															close_scope();
														}
			;

RetType		:	Type									{ $$ = $1; }
			|	VOID									{ $$ = new  Node(OUR_VOID); }
			;

Formals		:											{ $$ = new Node(); }
			|	FormalsList								{ $$ = $1;}
			;

FormalsList:	FormalsDecl								{ 
															$$ = new Node();
															$$->frmlList.push_back($1); }
			|	FormalsDecl  COMMA FormalsList			{	
															$$ = $3;
															$$->frmlList.insert($$->frmlList.begin(),$1); }
			;

FormalsDecl:	Type ID									{ $$ = new Node($2->id, $1->type);}
			|	Type ID LBRACK NUM RBRACK				{
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno,$2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal);
														}
			|	Type ID LBRACK NUM B RBRACK				{ 
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal); 
														}
			;

Statements	:	Statement
			|	Statements Statement
			;

Statement	:	LBRACE Mark3 Statements Mark2 RBRACE
			|	Type ID SC								{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
															EMIT("subu $sp, $sp, 4");
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															EMIT("sw " + REG_TO_STR(tempReg) + ", ($sp)");
															REG_FREE(tempReg);
															
														}
			|	Type ID ASSIGN Exp SC					{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if (!isAssignable($1->type, false , $1->arraySize,$4->type,$4->isArray, $4->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
															EMIT("subu $sp, $sp, 4");
															EMIT("sw " + REG_TO_STR($4->place) + ", ($sp)");
															REG_FREE($4->place);
														}
			|	Type ID LBRACK NUM RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
															ostringstream ostr;
															int arrayTopInStack = 4 * $4->intVal;
															ostr << arrayTopInStack;
															EMIT("subu $sp, $sp, " + arrayTopInStack);
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															for (int i = 0; i < $4->intVal; i++) {
																ostr << 4*i;
																EMIT("sw " + REG_TO_STR(tempReg) + ", "+ostr.str()+"($sp)");
															}
															REG_FREE(tempReg);
														}
			| Type ID LBRACK NUM B RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
															ostringstream ostr;
															int arrayTopInStack = 4 * $4->intVal;
															ostr << arrayTopInStack;
															EMIT("subu $sp, $sp, " + ostr.str());
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															for (int i = 0; i < $4->intVal; i++) {
																ostr << 4 * i;
																EMIT("sw " + REG_TO_STR(tempReg) + ", " + ostr.str() + "($sp)");
															}
															REG_FREE(tempReg);
														}
			| ID ASSIGN Exp SC							{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, node->isArray, node->arraySize, $3->type, $3->isArray, $3->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															ostringstream ostr;
															ostringstream ostr2;
															int varPosInStack = -4 * tableStack.top()->getVarPosByID($1->id);
															ostr << varPosInStack;
															if(!node->isArray){
																EMIT("sw " + REG_TO_STR($3->place) + ", " + ostr.str() + "($fp)");
															}
															else {
																Reg tempReg = REG_GET_AVAIL;
																for (int i = 0; i < node->arraySize; i++)
																{
																	ostr2 << (i * 4);
																	ostr << varPosInStack + (i * 4);
																	EMIT("lw " + REG_TO_STR(tempReg) + ", "+ ostr2.str()+"(" + REG_TO_STR($3->place) + ")");
																	EMIT("sw " + REG_TO_STR(tempReg) + ", " + ostr.str() + "($fp)");
																}
																REG_FREE(tempReg);
															}
															REG_FREE($3->place);

														}
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC		{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, false, node->arraySize, $6->type, $6->isArray , $6->arraySize) || !$3->isNum() || !node->isArray)
															{
																errorMismatch(yylineno);
																exit(0);
															}
															ostringstream ostr;
															int varPosInStack = -4 * tableStack.top()->getVarPosByID($1->id);
															varPosInStack += 4 * ($3->intVal);
															ostr << varPosInStack;
															EMIT("sw " + REG_TO_STR($6->place) + ", " + ostr.str() + "($fp)");
															REG_FREE($6->place);
														}
			|	Call SC
			|	RETURN SC								{
															Type_enum scopeRetType = (tableStack.top())->get_scope_type();
															if (scopeRetType != OUR_VOID)
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			|	RETURN Exp SC							{
															Type_enum scopeRetType = (tableStack.top())->get_scope_type();
															if (!isAssignable(scopeRetType, false, 0, $2->type, $2->isArray, $2->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			| 	IF Mark1 Statement Mark2 ELSE Mark3 Statement Mark2		%prec ELSE
			| 	IF Mark1 Statement Mark2								%prec IF	
			|	WHILE LPAREN Exp RPAREN{
															if (!$3->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															open_new_scope(true);
														} Statement Mark2
			|	BREAK SC								{ 
															if(!is_break_scope() )
															{
																errorUnexpectedBreak(yylineno);
																exit(0);
															}
														}
			;

Mark1		:		LPAREN Exp RPAREN					{
															if (!$2->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															open_new_scope(false);
														} ;

Mark2		:										{
														close_scope();
													};

Mark3		:										{
														open_new_scope(false);
													};


Call		:	ID LPAREN ExpList RPAREN				{ Type_enum *retType;
															if (check_func_exists($1->id,$3, &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno,$1->id);
																exit(0);
															}
														}
			|	ID LPAREN RPAREN						{	Type_enum *retType;
															if(check_func_exists($1->id,new Node(), &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno, $1->id);
																exit(0);
															}
														}
			;

ExpList		:	Exp										{	Node *node = new Node();
															node->expList.push_back($1);
															$$ = node; }
			|	Exp COMMA ExpList						{	Node *l = ($3);
															l->expList.insert(l->expList.begin(),$1);
															$$ = l; }
			;

Type		:	INT										{	$$ = new Node(OUR_INT); }
			|	BYTE									{	$$ = new Node(OUR_BYTE); }
			|	BOOL									{	$$ = new Node(OUR_BOOL); }
			;

Exp			:	LPAREN	Exp RPAREN						{	$$ = $2; }
			|	ID LBRACK Exp RBRACK					{
															if (!($3)->isNum())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!node->isArray)
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(node);
															$$->isArray = false;
															ostringstream ostr;
															int varPosInStack = -4 * tableStack.top()->getVarPosByID($1->id);
															varPosInStack += 4 * ($3->intVal);
															ostr << varPosInStack;
															EMIT("lw " + REG_TO_STR(REG_GET_AVAIL) + ", " + ostr.str() + "($fp)");
														}
			|	Exp BINOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															if($1->isByte() && $3->isByte())
															{
																$$ = new Node(OUR_BYTE);
															}
															else
															{
																$$ = new Node(OUR_INT);
															}

															$$->place = makeBinOpExp($2->id, $1->place, $3->place);
															if ($1->isByte() && $3->isByte())
															{
																EMIT("and " + REG_TO_STR($$->place) + " ," + REG_TO_STR($$->place) + " ,0xff");
															}

														}
			|	ID										{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
																{
																	$$ = node;
																}
															else
																{
																	errorUndef(yylineno, $1->id);
																	exit(0);
																}
															ostringstream ostr;
															int varPosInStack = -4 * tableStack.top()->getVarPosByID($1->id);
															ostr << varPosInStack;
															$$->place = REG_GET_AVAIL;
															if(!node->isArray){
																EMIT("lw " + REG_TO_STR($$->place) + ", " + ostr.str() + "($fp)");
															}
															else {
																EMIT("li " + REG_TO_STR($$->place) + ", "+ostr.str());
																EMIT("add " + REG_TO_STR($$->place) + ", " + REG_TO_STR($$->place) + ",$fp");
															}
														}
			|	Call									{	$$ = $1; }
			|	NUM										{	
															$$ = $1;
															$$->place = makeExp($$->id);
														}
			|	NUM B									{	
															int val = $1->intVal;
															if (val > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $1->id);
																exit(0);
															}
															$$ = new Node(OUR_BYTE,val); 
															$$->place = makeExp($$->id); 
														}
			|	STRING									{	$$ = new Node(OUR_STRING); }
			|	TRUE									{	$$ = new Node(OUR_BOOL); 
															$$->falseList = new vector<int>();
															$$->trueList = new vector<int>(MAKE_LIST(EMIT("b ")));
														}
			|	FALSE									{	$$ = new Node(OUR_BOOL); 
															$$->trueList = new vector<int>();
															$$->falseList = new vector<int>(MAKE_LIST(EMIT("b ")));
														}
			|	Exp	AND M	Exp								{	if(!($1->isBool() && $4->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
															BACKPATCH(*($1->trueList), $3->nextLabel);
															$$->trueList = new vector<int>(*($4->trueList));
															$$->falseList = new vector<int>(MERGE_LISTS(*($1->falseList), *($4->falseList)));
														}
			|	Exp	OR M Exp								{	if(!($1->isBool() && $4->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
															BACKPATCH(*($1->falseList), $3->nextLabel);
															$$->trueList = new vector<int>(MERGE_LISTS(*($1->trueList), *($4->trueList)));
															$$->falseList = new vector<int>(*($4->falseList));
														}
			|	Exp	RELOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
															makeRelOpExp($2->id, $1->place, $3->place, &($$->trueList), &($$->falseList));
														}
			|	NOT	Exp									{	if(!($2)->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL); 
															$$->trueList = $1->falseList;
															$$->falseList = $1->trueList;
														}
			;

M			: {
				$$->nextLabel = NEXT_LABEL;
			};
N			: {
				$$->codeLineNum = EMIT("b ");
			};


%%

int main()
{
	//set this to 1 to show more info
#ifdef DEBUG
	yydebug = 1;
#endif
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	if (yydebug)
		cout<<"Parse error: "<<message <<" line:"<<yylineno <<endl;
	exit(0);
}

void open_new_scope(bool is_break_allowed=false)
{
	bool is_current_while = is_break_scope();
	Type_enum retType = tableStack.top()->get_scope_type();
	VarTable *v = new VarTable(is_break_allowed || is_current_while, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void open_new_function_scope(Type_enum retType)
{
	VarTable *v = new VarTable(false, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void close_scope() {
	/*print*/
	endScope();
	tableStack.top()->print_scope();

	tableStack.pop();
	offsetStack.pop();

}

void make_table()
{
	funcTable = new FuncTable();
	vector<Node*> print_formals;
	vector<Node*> printi_formals;
	Node* print_formal = new Node(OUR_STRING);
	Node* printi_formal= new Node(OUR_INT);

	print_formals.push_back(print_formal);
	printi_formals.push_back(printi_formal);

	FuncTableEntry* print_entry = new FuncTableEntry("print", OUR_VOID, print_formals);
	FuncTableEntry* printi_entry= new FuncTableEntry("printi", OUR_VOID, printi_formals);

	funcTable->push(print_entry);
	funcTable->push(printi_entry);

	tableStack.push(funcTable);

	offsetStack.push(0);
}


bool check_var_exists_id(string id, Node** retNode)
{
	if (tableStack.size() <= 1)
		return false;
	
	vector<VarTableEntry*> current_table_rows = (dynamic_cast<VarTable*>(tableStack.top()))->rows;
	for (int i=0; i< current_table_rows.size() ; i++)
	{
		if (current_table_rows[i]->node->id == id)
		{
			*retNode = (current_table_rows[i]->node);
			return true;
		}
	}

	VarTable* temp = dynamic_cast<VarTable*>(tableStack.top());
	tableStack.pop();
	bool res = check_var_exists_id(id, retNode);
	tableStack.push(temp);
	return res;
}

bool check_func_exists(string& id, Node* expListNode, Type_enum **retType)
{
	if (!check_func_exists_name(id))
	{
		return false;
	}

	vector<string> types;
	FuncTableEntry* func;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id )
		{
			func = (*it);
			break;
		}
		
	}

	if (func->nodeList.size() != expListNode->expList.size())
	{
		for (int i = 0; i < func->nodeList.size(); i++)
		{
			if (func->nodeList[i]->isArray)
				types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
			else
				types.push_back(get_type_string(func->nodeList[i]->type));
		}
		errorPrototypeMismatch(yylineno, id, types);
		exit(0);
	}


		for (int j = 0; j<func->nodeList.size(); j++)
		{
			if(!isAssignable(func->nodeList[j], expListNode->expList[j]))
			{
				for (int i = 0; i < func->nodeList.size(); i++)
				{
					if (func->nodeList[i]->isArray)
						types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
					else
						types.push_back(get_type_string(func->nodeList[i]->type));
				}
				errorPrototypeMismatch(yylineno, id, types);
				exit(0);
			}
		}
		*retType = &func->retType;
		return true;

}

bool check_func_exists_name(string id)
{
	int i = 0;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id)
		{
			return true;
		}

	}
	return false;
}

bool is_break_scope()
{
	return tableStack.top()->is_while;
}

bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray,int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize)
{
	if (typeAssignedTo == OUR_VOID || TypeAssigned == OUR_VOID || typeAssignedTo == TYPE_ERROR || TypeAssigned == TYPE_ERROR)
		return false;
	if (typeAssignedTo == TypeAssigned || (!assignedToIsArray && typeAssignedTo == OUR_INT && TypeAssigned == OUR_BYTE))
	{
		if (assignedToIsArray)
			return assignedToIsArray == assignedIsArray && assignedToSize == assingedSize;
		else
			return assignedToIsArray == assignedIsArray;
	}

	return false;
}
bool isAssignable(Node* assignedTo, Node* assigned)
{
	Type_enum typeAssignedTo = assignedTo->type;
	Type_enum TypeAssigned = assigned->type;
	bool assignedToIsArray = assignedTo->isArray;
	bool assignedIsArray = assigned->isArray;
	int assignedToSize = assignedTo->arraySize;
	int assingedSize = assigned->arraySize;

	if (typeAssignedTo == OUR_VOID || TypeAssigned == OUR_VOID || typeAssignedTo == TYPE_ERROR || TypeAssigned == TYPE_ERROR)
		return false;

	if (typeAssignedTo == TypeAssigned || (!assignedToIsArray && typeAssignedTo == OUR_INT && TypeAssigned == OUR_BYTE))
	{
		if (assignedToIsArray)
			return assignedToIsArray == assignedIsArray && assignedToSize == assingedSize;
		else
			return assignedToIsArray == assignedIsArray;
	}

	return false;
}