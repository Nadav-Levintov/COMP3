%{
	#include <iostream>
	#include <string>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"
	#include "asm.hpp"
	#include <sstream>


	using namespace std;
	using namespace output;

#define BYTE_MAX_SIZE 255
#define ARRAY_MIN_SIZE 1
#define YYERROR_VERBOSE 1
#define YYDEBUG 1 

	stack<Table*> tableStack;
	FuncTable* funcTable;
	stack<int> offsetStack;
	static int stringCounter = 0;
	static int debug_counter = 0;

	void make_table();
	bool is_break_scope();
	bool check_var_exists_id(string id, Node** retNode);
	void open_new_scope(bool is_break_allowed);
	void open_new_function_scope(Type_enum retType);
	bool check_func_exists(string& id, Node* expListNode, Type_enum **retType);
	void close_scope(bool is_break=false);
	bool check_func_exists_name(string id);
	bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray, int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize);
	bool isAssignable(Node* assignedTo, Node* assigned);
	int get_pos_var_exists_id(string id);
	void clear_ostr(ostringstream *ostr)
	{
		ostr->str("");
		ostr->clear();
	}

%}

%start S
%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%nonassoc IF
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOPPM
%left BINOPMD
%token ID
%token NUM
%token STRING
%nonassoc  ELSE
%token EOF1

%%

S			:	Program EOF1 {
															if (!check_func_exists_name("main"))
															{
																errorMainMissing();
																exit(0);
															}

															FuncTableEntry* func;

															for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
															{
																if ((*it)->id == "main" )
																{
																	func = (*it);
																	break;
																}
																
															}
															
															if (func->nodeList.size() != 0)
															{
																errorMainMissing();
																exit(0);
															}

															if (OUR_VOID != func->retType)
															{
																errorMainMissing();
																exit(0);
															}

															/*print*/
															//endScope();
															//tableStack.top()->print_scope();
															tableStack.pop();
															offsetStack.pop();
															//RegPool::testAllFree();
														}
			;

Program		: { make_table(); }	Funcs					
			;

Funcs		:
			|	FuncDecl Funcs
			;

FuncDecl	:	RetType ID LPAREN Formals RPAREN		{
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															FuncTable *f_table = dynamic_cast<FuncTable*>(tableStack.top());
															Type_enum retType = $1->type;
															FuncTableEntry *func_entry = new FuncTableEntry($2->id, retType, $4->frmlList);
															f_table->push(func_entry);
															open_new_function_scope($1->type);
															int param_offset = 0;
															for (vector<Node*>::iterator it = $4->frmlList.begin();it != $4->frmlList.end(); it++)
															{
																VarTableEntry *var_entry;
																Node* temp;
																Node* frml = (*it);
																if (check_var_exists_id(frml->id, &temp) || check_func_exists_name(frml->id))
																{
																	errorDef(yylineno, frml->id);
																	exit(0);
																}
																if (frml->isArray)
																{
																	param_offset -= frml->arraySize;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																else {
																	param_offset--;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																dynamic_cast<VarTable*>(tableStack.top())->push(var_entry);
															}
															EMIT_COMMENT("*************");
															EMIT($2->id + ":");
															EMITFP;
														} LBRACE Statements RBRACE {
															close_scope();
															EMIT("jr $ra");
														}
			;

RetType		:	Type									{ $$ = $1; }
			|	VOID									{ $$ = new  Node(OUR_VOID); }
			;

Formals		:											{ $$ = new Node(); }
			|	FormalsList								{ $$ = $1;}
			;

FormalsList:	FormalsDecl								{ 
															$$ = new Node();
															$$->frmlList.push_back($1); }
			|	FormalsDecl  COMMA FormalsList			{	
															$$ = $3;
															$$->frmlList.insert($$->frmlList.begin(),$1); }
			;

FormalsDecl:	Type ID									{ $$ = new Node($2->id, $1->type);}
			|	Type ID LBRACK NUM RBRACK				{
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno,$2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal);
														}
			|	Type ID LBRACK NUM B RBRACK				{ 
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal); 
														}
			;

Statements	:	Statement								{
															$$ = $1;
														}
			|	Statements Statement					{
															$$ = new Node();
															$$->breaksList = new vector<int>(MERGE_LISTS(*($1->breaksList), *($2->breaksList)));
														}
			;

Statement:	LBRACE Mark3 Statements Mark2 RBRACE{ $$ = $3; }
			|	Type ID SC								{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
															EMIT("subu $sp, $sp, 4");
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															EMIT("sw " + REG_TO_STR(tempReg) + ", 0($sp)");
															REG_FREE(tempReg);															
														}
			|	Type ID ASSIGN Exp SC					{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if (!isAssignable($1->type, false , $1->arraySize,$4->type,$4->isArray, $4->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
															if ($4->type == OUR_BOOL && $4->place == MAX_REG)
															{
																EMIT_COMMENT("Type ID ASSIGN Exp SC");
																$4->place = handleBoolVal($4->trueList, $4->falseList);
															}
															EMIT("subu $sp, $sp, 4");
															EMIT("sw " + REG_TO_STR($4->place) + ", 0($sp)");
															REG_FREE($4->place);
														}
			|	Type ID LBRACK NUM RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
															ostringstream ostr;
															int arrayTopInStack = 4 * $4->intVal;
															ostr << arrayTopInStack;
															EMIT("subu $sp, $sp, " + ostr.str());
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															for (int i = 0; i < $4->intVal; i++) {
																clear_ostr(&ostr);
																ostr << 4*i;
																EMIT("sw " + REG_TO_STR(tempReg) + ", "+ostr.str()+"($sp)");
															}
															REG_FREE(tempReg);
														}
			| Type ID LBRACK NUM B RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
															ostringstream ostr;
															int arrayTopInStack = 4 * $4->intVal;
															ostr << arrayTopInStack;
															EMIT("subu $sp, $sp, " + ostr.str());
															Reg tempReg = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tempReg) + ", 0");
															for (int i = 0; i < $4->intVal; i++) {
																clear_ostr(&ostr);
																ostr << 4 * i;
																EMIT("sw " + REG_TO_STR(tempReg) + ", " + ostr.str() + "($sp)");
															}
															REG_FREE(tempReg);
														}
			| ID ASSIGN Exp SC							{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, node->isArray, node->arraySize, $3->type, $3->isArray, $3->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															ostringstream ostr;
															ostringstream ostr2;
															int varPosInStack = -4 * get_pos_var_exists_id($1->id);
															ostr << varPosInStack;
															if(!node->isArray){
																if ($3->type == OUR_BOOL && $3->place == MAX_REG)
																{
																	EMIT_COMMENT("ID ASSIGN Exp SC");
																	$3->place = handleBoolVal($3->trueList, $3->falseList);
																}
																EMIT("sw " + REG_TO_STR($3->place) + ", " + ostr.str() + "($fp)");
															}
															else {
																Reg tempReg = REG_GET_AVAIL;
																for (int i = 0; i < node->arraySize; i++)
																{
																	clear_ostr(&ostr);
																	clear_ostr(&ostr2);
																	ostr2 << (-i * 4);
																	ostr << varPosInStack + (-i * 4);
																	EMIT("lw " + REG_TO_STR(tempReg) + ", "+ ostr2.str()+"(" + REG_TO_STR($3->place) + ")");
																	EMIT("sw " + REG_TO_STR(tempReg) + ", " + ostr.str() + "($fp)");
																}
																REG_FREE(tempReg);
															}
															REG_FREE($3->place);
														}
			|	ID LBRACK Exp RBRACK ASSIGN					{
																Node* node;
																if (!check_var_exists_id($1->id, &node))
																{
																	errorUndef(yylineno, $1->id);
																	exit(0);
																}
																if ($3->place != MAX_REG)
																{
																	ostringstream ostr2;
																	ostr2 << node->arraySize;
																	Reg tmp = REG_GET_AVAIL;
																	EMIT("li " + REG_TO_STR(tmp) + ", " + ostr2.str());
																	EMIT("bge " + REG_TO_STR($3->place) + ", " + REG_TO_STR(tmp) + ", outOfBoundErr");
																	EMIT("li " + REG_TO_STR(tmp) + ", 0");
																	EMIT("blt " + REG_TO_STR($3->place) + ", " + REG_TO_STR(tmp) + ", outOfBoundErr");
																	

																	ostringstream ostr;
																	int varPosInStack = -1 * get_pos_var_exists_id($1->id);
																	//varPosInStack += 1;//(varPosInStack <= 0) ? 1 : 2;
																	//varPosInStack *= 4;
																	//varPosInStack -= 4 * (($3->intVal)+1);
																	
																	Reg tmp2 = REG_GET_AVAIL;
																	ostr << varPosInStack;
																	EMIT("li " + REG_TO_STR(tmp) + ", " + ostr.str());
																	EMIT("li " + REG_TO_STR(tmp2) + ", 4");
																	EMIT("sub " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp) + ", " + REG_TO_STR($3->place));
																	EMIT("mult " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp2));
																	EMIT("mflo " + REG_TO_STR(tmp));
																	EMIT("add " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp) + ", $fp");
																	REG_FREE(tmp2);
																	$1->place = tmp;// save for after the rest

																}
															} Exp SC		{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, false, node->arraySize, $7->type, $7->isArray , $7->arraySize) || !$3->isNum() || !node->isArray)
															{
																errorMismatch(yylineno);
																exit(0);
															}
																														
															if ($7->type == OUR_BOOL && $7->place == MAX_REG)
															{
																EMIT_COMMENT("ID LBRACK Exp RBRACK ASSIGN Exp SC");
																$7->place = handleBoolVal($7->trueList, $7->falseList);
															}
															EMIT("sw " + REG_TO_STR($7->place) + ", 0("+REG_TO_STR($1->place)+")");
															REG_FREE($7->place);
															REG_FREE($3->place);
															REG_FREE($1->place);
															

														}
			|	Call SC									{	$$ = $1;
															if ($$->type != OUR_VOID)
															{
																$$->place = Reg(v0);
															}
														}
			|	RETURN SC								{
															Type_enum scopeRetType = (tableStack.top())->get_scope_type();
															if (scopeRetType != OUR_VOID)
															{
																errorMismatch(yylineno);
																exit(0);
															}

															VarTable* varTable = static_cast<VarTable*>(tableStack.top());

															int numOfCellsToFree = 0;
															vector<VarTableEntry*> current_table_rows = varTable->rows;
															for (int i = 0; i< current_table_rows.size(); i++)
															{
																if (current_table_rows[i]->offset >= 0)
																{
																	if (current_table_rows[i]->node->isArray)
																	{
																		numOfCellsToFree += current_table_rows[i]->node->arraySize;
																	}
																	else
																	{
																		numOfCellsToFree++;
																	}
																}
															}
															ostringstream ostr;
															numOfCellsToFree *= 4;
															ostr << numOfCellsToFree;
															if(numOfCellsToFree)
																EMIT("add $sp, $sp, " + ostr.str());
															EMIT("jr $ra");
														}
			|	RETURN Exp SC							{
															Type_enum scopeRetType = (tableStack.top())->get_scope_type();
															if (!isAssignable(scopeRetType, false, 0, $2->type, $2->isArray, $2->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}

															VarTable* varTable = static_cast<VarTable*>(tableStack.top());

															int numOfCellsToFree = 0;
															vector<VarTableEntry*> current_table_rows = varTable->rows;
															for (int i = 0; i< current_table_rows.size(); i++)
															{
																if (current_table_rows[i]->offset >= 0)
																{
																	if (current_table_rows[i]->node->isArray)
																	{
																		numOfCellsToFree += current_table_rows[i]->node->arraySize;
																	}
																	else
																	{
																		numOfCellsToFree++;
																	}
																}
															}
															ostringstream ostr;
															numOfCellsToFree *= 4;
															ostr << numOfCellsToFree;
															if (numOfCellsToFree)
																EMIT("add $sp, $sp, " + ostr.str());
															if ($2->type == OUR_BOOL && $2->place==MAX_REG)
															{
																EMIT_COMMENT("RETURN Exp SC");
																$2->place = handleBoolVal($2->trueList, $2->falseList);
															}
															EMIT("move $v0, " + REG_TO_STR($2->place));
															REG_FREE($2->place);
															EMIT("jr $ra");
														}
			| 	IF Mark1 M Statement Mark2 M ELSE N Mark3 M Statement Mark2 M {
															$$ = new Node();
															EMIT_COMMENT("IF WITH ELSE");
															$$->breaksList = new vector<int>(MERGE_LISTS(*($4->breaksList), *($11->breaksList)));
															BACKPATCH(*($2->trueList), $3->nextLabel);
															BACKPATCH(*($2->falseList), $10->nextLabel);
															vector<int> tmpList;
															tmpList.push_back($8->codeLineNum);
															BACKPATCH(tmpList, $13->nextLabel);
															} %prec ELSE
			| 	IF  Mark1 M Statement Mark2	M			  	{
															$$ = $4;
															EMIT_COMMENT("IF NO ELSE");
															BACKPATCH(*($2->trueList), $3->nextLabel);
															BACKPATCH(*($2->falseList), $6->nextLabel);
															} %prec IF
			|	WHILE LPAREN M Exp RPAREN               {
															if (!$4->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															open_new_scope(true);
															$$ = new Node();
															EMIT_COMMENT("WHILE PRE STATEMNTS");
															$$->breaksList = new vector<int>();
															//if (!$4->relOp)
															{
																if ($4->place == MAX_REG)
																{
																	EMIT_COMMENT("WHILE LPAREN M Exp RPAREN ");
																	$4->place = handleBoolVal($4->trueList, $4->falseList);
																}
																Reg tmp = REG_GET_AVAIL;
																EMIT("li " + REG_TO_STR(tmp) + ",0");
																$4->falseList->push_back(EMIT("beq " + REG_TO_STR($4->place) + ", " + REG_TO_STR(tmp) + ", "));
																$4->trueList->push_back(EMIT("b "));
																REG_FREE(tmp);
																REG_FREE($4->place);
															}
														} M Statement Mark2 N M {
															vector<int> *tmpList = new vector<int>();
															tmpList->push_back($10->codeLineNum);
															int temp = $10->codeLineNum;
															EMIT_COMMENT("WHILE STATMENTS");
															BACKPATCH(*($8->breaksList),$11->nextLabel);
															BACKPATCH(*tmpList, $3->nextLabel);
															BACKPATCH(*($4->trueList), $7->nextLabel);
															BACKPATCH(*($4->falseList), $11->nextLabel);
														}
			|	BREAK SC								{ 
															if(!is_break_scope() )
															{
																errorUnexpectedBreak(yylineno);
																exit(0);
															}
															EMIT_COMMENT("BREAK");
															$$ = new Node();
															close_scope(true);
															$$->breaksList = new vector<int>(MAKE_LIST(EMIT("b ")));
														}
			;

Mark1		:		LPAREN Exp RPAREN					{
															if (!$2->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = $2;
															if ($2->place != MAX_REG)
															{
																EMIT_COMMENT("IF BOOL Condition");
																Reg tmp = REG_GET_AVAIL;
																EMIT("li " + REG_TO_STR(tmp) + ",0");
																$2->falseList->push_back(EMIT("beq " + REG_TO_STR($2->place) + ", " + REG_TO_STR(tmp) + ", "));
																$2->trueList->push_back(EMIT("b "));
																REG_FREE(tmp);
																REG_FREE($2->place);
															}
															open_new_scope(false);
														} ;

Mark2		:											{
															close_scope();
														};

Mark3		:											{
															open_new_scope(false);
														};


Call		:	ID LPAREN ExpList RPAREN				{ Type_enum *retType;
															if (check_func_exists($1->id,$3, &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno,$1->id);
																exit(0);
															}
															for (int i = 0; i < $3->expList.size(); i++)
															{
																if (!($3->expList[i]->isArray) && $3->expList[i]->type == OUR_BOOL && $3->expList[i]->place == MAX_REG)
																{
																	EMIT_COMMENT("BOOL EXP in PARAMS LIST");
																	$3->expList[i]->place = handleBoolVal($3->expList[i]->trueList, $3->expList[i]->falseList);
																}
															}
															SAVE_ALL_REGS;
															EMIT("subu $sp ,$sp ,4");
															EMIT("sw $fp, 0($sp)");
															EMIT("subu $sp ,$sp ,4");
															EMIT("sw $ra, 0($sp)");
															//Putting parameters on stack
															for (int i = 0; i < $3->expList.size(); i++)
															{
																if ($3->expList[i]->isArray)
																{
																	EMIT_COMMENT("PASSING ARR BY VAL");
																	Reg tmp = REG_GET_AVAIL;
																	for (int j = 0; j < $3->expList[i]->arraySize; j++)
																	{
																		EMIT("subu $sp ,$sp ,4");
																		ostringstream ostr;
																		ostr << j * -4;
																		
																		EMIT("lw "+REG_TO_STR(tmp)+", " + ostr.str() + "(" + REG_TO_STR($3->expList[i]->place) + ")");
																		EMIT("sw " + REG_TO_STR(tmp) + ", 0($sp)");
																		
																	}
																	REG_FREE(tmp);
																}
																else {
																	EMIT("subu $sp ,$sp ,4");
																	EMIT("sw " + REG_TO_STR($3->expList[i]->place) + ", 0($sp)");
																}
																REG_FREE($3->expList[i]->place);
															}
															EMIT("jal " + $1->id);
															int memToFree = 0;
															for (int i = 0; i < $3->expList.size(); i++)
															{
																if ($3->expList[i]->isArray)
																{
																	memToFree += $3->expList[i]->arraySize;
																}
																else
																{
																	memToFree++;
																}
															}
															ostringstream ostr;
															ostr << 4 * memToFree;
															EMIT("addu $sp ,$sp ,"+ostr.str());
															EMIT("lw $ra, 0($sp)");
															EMIT("addu $sp ,$sp ,4");
															EMIT("lw $fp, 0($sp)");
															EMIT("addu $sp ,$sp ,4");
															LOAD_ALL_REGS;
														}
			|	ID LPAREN RPAREN						{	Type_enum *retType;
															if(check_func_exists($1->id,new Node(), &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno, $1->id);
																exit(0);
															}

															SAVE_ALL_REGS;
															EMIT("subu $sp ,$sp ,4");
															EMIT("sw $fp, 0($sp)");
															EMIT("subu $sp ,$sp ,4");
															EMIT("sw $ra, 0($sp)");
															EMIT("jal " + $1->id);
															EMIT("lw $ra, 0($sp)");
															EMIT("addu $sp ,$sp ,4");
															EMIT("lw $fp, 0($sp)");
															EMIT("addu $sp ,$sp ,4");
															LOAD_ALL_REGS;
														}
			;

ExpList		:	Exp										{	Node *node = new Node();
															node->expList.push_back($1);
															$$ = node; }
			|	Exp COMMA ExpList						{	Node *l = ($3);
															l->expList.insert(l->expList.begin(),$1);
															$$ = l; }
			;

Type		:	INT										{	$$ = new Node(OUR_INT); }
			|	BYTE									{	$$ = new Node(OUR_BYTE); }
			|	BOOL									{	$$ = new Node(OUR_BOOL); }
			;

Exp			:	LPAREN	Exp RPAREN						{	$$ = $2; }
			|	ID LBRACK Exp RBRACK					{
															if (!($3)->isNum())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!node->isArray)
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(node);
															$$->isArray = false;
															$$->place = REG_GET_AVAIL;
															$$->trueList = new vector<int>;
															$$->falseList = new vector<int>;
															ostringstream ostr;
															ostringstream ostr2;
															int varPosInStack;
															ostr2 << node->arraySize;
															Reg tmp = REG_GET_AVAIL;
															EMIT("li " + REG_TO_STR(tmp) + ", " + ostr2.str());
															EMIT("bge " + REG_TO_STR($3->place) + ", " + REG_TO_STR(tmp) + ", outOfBoundErr");
															EMIT("li " + REG_TO_STR(tmp) + ", 0");
															EMIT("blt " + REG_TO_STR($3->place) + ", " + REG_TO_STR(tmp) + ", outOfBoundErr");
															Reg tmp2 = REG_GET_AVAIL;
															clear_ostr(&ostr);
															varPosInStack = -get_pos_var_exists_id($1->id);
															ostr << varPosInStack;
															EMIT("li " + REG_TO_STR(tmp) + ", " + ostr.str());
															EMIT("li " + REG_TO_STR(tmp2) + ", 4");
															EMIT("sub " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp) + ", " + REG_TO_STR($3->place));
															EMIT("mult " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp2));
															EMIT("mflo " + REG_TO_STR(tmp));
															EMIT("add " + REG_TO_STR(tmp) + ", " + REG_TO_STR(tmp) + ", $fp");
															REG_FREE(tmp2);
															
															EMIT("lw " + REG_TO_STR($$->place) + ", 0(" + REG_TO_STR(tmp) + ")");
															REG_FREE(tmp);
															REG_FREE($3->place);
														}
			|	Exp BINOPPM Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															if($1->isByte() && $3->isByte())
															{
																$$ = new Node(OUR_BYTE);
															}
															else
															{
																$$ = new Node(OUR_INT);
															}
															EMIT_COMMENT("BINOPPM regs: " + REG_TO_STR($1->place) + ", " + REG_TO_STR($3->place));
															$$->place = makeBinOpExp($2->id, $1->place, $3->place);
															if ($1->isByte() && $3->isByte())
															{
																EMIT("and " + REG_TO_STR($$->place) + " ," + REG_TO_STR($$->place) + " ,0xff");
															}

														}
			| Exp BINOPMD Exp							{ if (!($1->isNum() && $3->isNum()))
														{
															errorMismatch(yylineno);
															exit(0);
														}
														if ($1->isByte() && $3->isByte())
														{
															$$ = new Node(OUR_BYTE);
														}
														else
														{
															$$ = new Node(OUR_INT);
														}

														$$->place = makeBinOpExp($2->id, $1->place, $3->place);
														if ($1->isByte() && $3->isByte())
														{
															EMIT("and " + REG_TO_STR($$->place) + " ," + REG_TO_STR($$->place) + " ,0xff");
														}

														}
			|	ID										{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
																{
																	$$ = new Node(node);
																}
															else
																{
																	errorUndef(yylineno, $1->id);
																	exit(0);
																}
															ostringstream ostr;
															int varPosInStack = -4 * get_pos_var_exists_id($1->id);
															ostr << varPosInStack;
															//TODO: should we free the reg in node?
															$$->place = REG_GET_AVAIL;
															$$->trueList = new vector<int>;
															$$->falseList = new vector<int>;
															if (!node->isArray) {
																EMIT("lw " + REG_TO_STR($$->place) + ", " + ostr.str() + "($fp)");
															}
															else {
																EMIT("li " + REG_TO_STR($$->place) + ", " + ostr.str());
																EMIT("add " + REG_TO_STR($$->place) + ", " + REG_TO_STR($$->place) + ",$fp");
															}															
														}
			|	Call									{	$$ = $1;
															if ($$->place == MAX_REG)
															{
																$$->place = REG_GET_AVAIL;
															}
															EMIT("move " + REG_TO_STR($$->place) + ", $v0");
														}
			|	NUM										{	
															$$ = $1;
															if ($1->place != MAX_REG)
															{
																REG_FREE($1->place);
															}
															$$->place = makeExp($1->id);
														}
			|	NUM B									{	
															int val = $1->intVal;
															if (val > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $1->id);
																exit(0);
															}
															$$ = new Node(OUR_BYTE,val);
															if ($1->place != MAX_REG)
															{
																REG_FREE($1->place);
															}
															$$->place = makeExp($1->id); 
														}
			|	STRING									{	$$ = new Node(OUR_STRING); 
															ostringstream label;
															label <<"__str" << stringCounter;
															stringCounter++;
															EMITDATA(label.str() + ": .asciiz " + string("\"") + $1->id + string("\""));
															$$->place = REG_GET_AVAIL;
															EMIT("la " +REG_TO_STR($$->place) + ", " + label.str()); 
														}
			|	TRUE									{	$$ = new Node(OUR_BOOL);
															EMIT_COMMENT("TRUE");
															$$->falseList = new vector<int>();
															$$->trueList = new vector<int>(MAKE_LIST(EMIT("b ")));
														}
			|	FALSE									{	$$ = new Node(OUR_BOOL); 
															EMIT_COMMENT("FALSE");
															$$->trueList = new vector<int>();
															$$->falseList = new vector<int>(MAKE_LIST(EMIT("b ")));
														}
			|	Exp AND									{
															if ($1->place != MAX_REG)
															{
																EMIT_COMMENT("$1 has a reg");

																if ($1->falseList->size() == 0 && $1->trueList->size() == 0)
																{
																	EMIT_COMMENT("$1 lists are empty");

																	Reg tmp = REG_GET_AVAIL;
																	EMIT("li " + REG_TO_STR(tmp) + ",0");
																	$1->falseList->push_back(EMIT("beq " + REG_TO_STR($1->place) + ", " + REG_TO_STR(tmp) + ", "));
																	$1->trueList->push_back(EMIT("b "));
																	REG_FREE(tmp);
																}
																REG_FREE($1->place);
															}
														} M	Exp								{	if(!($1->isBool() && $5->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															EMIT_COMMENT("AND");
															$$ = new Node(OUR_BOOL);

															if ($5->place != MAX_REG)
															{
																EMIT_COMMENT("$4 has a reg");

																if ($5->falseList->size() == 0 && $5->trueList->size() == 0)
																{
																	EMIT_COMMENT("$5 lists are empty");

																	Reg tmp = REG_GET_AVAIL;
																	EMIT("li " + REG_TO_STR(tmp) + ",0");
																	$5->falseList->push_back(EMIT("beq " + REG_TO_STR($5->place) + ", " + REG_TO_STR(tmp) + ", "));
																	$5->trueList->push_back(EMIT("b "));
																	REG_FREE(tmp);
																	
																}
																REG_FREE($5->place);
															}

															BACKPATCH(*($1->trueList), $4->nextLabel);
															$$->trueList = new vector<int>(*($5->trueList));
															$$->falseList = new vector<int>(MERGE_LISTS(*($1->falseList), *($5->falseList)));
															
															
														}
			|	Exp OR									{
																if ($1->place != MAX_REG)
																{
																	EMIT_COMMENT("$1 has a reg");

																	if ($1->falseList->size() == 0 && $1->trueList->size() == 0)
																	{
																		EMIT_COMMENT("$1 lists are empty");

																		Reg tmp = REG_GET_AVAIL;
																		EMIT("li " + REG_TO_STR(tmp) + ",0");
																		$1->falseList->push_back(EMIT("beq " + REG_TO_STR($1->place) + ", " + REG_TO_STR(tmp) + ", "));
																		$1->trueList->push_back(EMIT("b "));
																		REG_FREE(tmp);
																	}
																	REG_FREE($1->place);
																}
															}
															 M Exp {	if(!($1->isBool() && $5->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															EMIT_COMMENT("OR");
															$$ = new Node(OUR_BOOL);
															

															if ($5->place != MAX_REG)
															{
																EMIT_COMMENT("$5 has a reg");

																if ($5->falseList->size() == 0 && $5->trueList->size() == 0)
																{
																	EMIT_COMMENT("$5 lists are empty");
																	Reg tmp = REG_GET_AVAIL;
																	EMIT("li " + REG_TO_STR(tmp) + ",0");
																	$5->falseList->push_back(EMIT("beq " + REG_TO_STR($5->place) + ", " + REG_TO_STR(tmp) + ", "));
																	$5->trueList->push_back(EMIT("b "));
																	REG_FREE(tmp);
																}
																REG_FREE($5->place);
															}

															BACKPATCH(*($1->falseList), $4->nextLabel);
															$$->trueList = new vector<int>(MERGE_LISTS(*($1->trueList), *($5->trueList)));
															$$->falseList = new vector<int>(*($5->falseList));

														}
			|	Exp	RELOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															EMIT_COMMENT("RELOP");
															$$ = new Node(OUR_BOOL);
															$$->relOp = true;
															Node *tmp = $$;
															makeRelOpExp($2->id, $1->place, $3->place, &($$->trueList), &($$->falseList));
														}
			|	NOT	Exp									{	if(!($2)->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
															EMIT_COMMENT("NOT");
															$$->trueList = $2->falseList;
															$$->falseList = $2->trueList;
															if ($2->place != MAX_REG)
															{
																$$->place = REG_GET_AVAIL;
																EMIT("xor " + REG_TO_STR($$->place) + ", " + REG_TO_STR($2->place) +",1");
																REG_FREE($2->place);
															}
														}
			;

M			:											{
															$$ = new Node();
															$$->nextLabel = NEXT_LABEL;
														};
N			:											{
															$$ = new Node();
															$$->codeLineNum = EMIT("b ");
														};


%%

int main()
{
	//set this to 1 to show more info
#ifdef DEBUG
	yydebug = 1;
#endif
	createDivByZeroErrFunc();
	createOutOfBoundErrFunc();
	createPrintFunc();
	createPrintiFunc();
	yyparse();
	CodeBuffer::instance().printDataBuffer();
	CodeBuffer::instance().printCodeBuffer();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	if (yydebug)
		cout<<"Parse error: "<<message <<" line:"<<yylineno <<endl;
	exit(0);
}

void open_new_scope(bool is_break_allowed=false)
{
	bool is_current_while = is_break_scope();
	Type_enum retType = tableStack.top()->get_scope_type();
	VarTable *v = new VarTable(is_break_allowed || is_current_while, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void open_new_function_scope(Type_enum retType)
{
	VarTable *v = new VarTable(false, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void close_scope(bool is_break) {
	/*print*/
	//endScope();
	//tableStack.top()->print_scope();
	VarTable* varTable = static_cast<VarTable*>(tableStack.top());

	if (!is_break)
	{
		tableStack.pop();
		offsetStack.pop();
	}

	int numOfCellsToFree = 0;
	vector<VarTableEntry*> current_table_rows = varTable->rows;
	for (int i = 0; i< current_table_rows.size(); i++)
	{
		if (current_table_rows[i]->offset >= 0)
		{
			if (current_table_rows[i]->node->isArray)
			{
				numOfCellsToFree += current_table_rows[i]->node->arraySize;
			}
			else
			{
				numOfCellsToFree++;
			}
		}
	}
	ostringstream ostr;
	numOfCellsToFree *= 4;
	ostr << numOfCellsToFree;
	if (numOfCellsToFree)
		EMIT("add $sp, $sp, " + ostr.str());
}

void make_table()
{
	funcTable = new FuncTable();
	vector<Node*> print_formals;
	vector<Node*> printi_formals;
	Node* print_formal = new Node(OUR_STRING);
	Node* printi_formal= new Node(OUR_INT);

	print_formals.push_back(print_formal);
	printi_formals.push_back(printi_formal);

	FuncTableEntry* print_entry = new FuncTableEntry("print", OUR_VOID, print_formals);
	FuncTableEntry* printi_entry= new FuncTableEntry("printi", OUR_VOID, printi_formals);

	funcTable->push(print_entry);
	funcTable->push(printi_entry);

	tableStack.push(funcTable);

	offsetStack.push(0);
}


bool check_var_exists_id(string id, Node** retNode)
{
	if (tableStack.size() <= 1)
		return false;

	vector<VarTableEntry*> current_table_rows = (dynamic_cast<VarTable*>(tableStack.top()))->rows;
	for (int i = 0; i < current_table_rows.size(); i++)
	{
		if (current_table_rows[i]->node->id == id)
		{
			*retNode = (current_table_rows[i]->node);
			return true;
		}
	}

	VarTable* temp = dynamic_cast<VarTable*>(tableStack.top());
	tableStack.pop();
	bool res = check_var_exists_id(id, retNode);
	tableStack.push(temp);
	return res;
}

int get_pos_var_exists_id(string id)
{
	if (tableStack.size() <= 1)
		assert(0);

	vector<VarTableEntry*> current_table_rows = (dynamic_cast<VarTable*>(tableStack.top()))->rows;
	for (int i = 0; i< current_table_rows.size(); i++)
	{
		if (current_table_rows[i]->node->id == id)
		{
			return current_table_rows[i]->offset + 1;
		}
	}

	VarTable* temp = dynamic_cast<VarTable*>(tableStack.top());
	tableStack.pop();
	int res = get_pos_var_exists_id(id);
	tableStack.push(temp);
	return res;
}

bool check_func_exists(string& id, Node* expListNode, Type_enum **retType)
{
	if (!check_func_exists_name(id))
	{
		return false;
	}

	vector<string> types;
	FuncTableEntry* func;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id )
		{
			func = (*it);
			break;
		}
		
	}

	if (func->nodeList.size() != expListNode->expList.size())
	{
		for (int i = 0; i < func->nodeList.size(); i++)
		{
			if (func->nodeList[i]->isArray)
				types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
			else
				types.push_back(get_type_string(func->nodeList[i]->type));
		}
		errorPrototypeMismatch(yylineno, id, types);
		exit(0);
	}


		for (int j = 0; j<func->nodeList.size(); j++)
		{
			if(!isAssignable(func->nodeList[j], expListNode->expList[j]))
			{
				for (int i = 0; i < func->nodeList.size(); i++)
				{
					if (func->nodeList[i]->isArray)
						types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
					else
						types.push_back(get_type_string(func->nodeList[i]->type));
				}
				errorPrototypeMismatch(yylineno, id, types);
				exit(0);
			}
		}
		*retType = &func->retType;
		return true;

}

bool check_func_exists_name(string id)
{
	int i = 0;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id)
		{
			return true;
		}

	}
	return false;
}

bool is_break_scope()
{
	return tableStack.top()->is_while;
}

bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray,int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize)
{
	if (typeAssignedTo == OUR_VOID || TypeAssigned == OUR_VOID || typeAssignedTo == TYPE_ERROR || TypeAssigned == TYPE_ERROR)
		return false;
	if (typeAssignedTo == TypeAssigned || (!assignedToIsArray && typeAssignedTo == OUR_INT && TypeAssigned == OUR_BYTE))
	{
		if (assignedToIsArray)
			return assignedToIsArray == assignedIsArray && assignedToSize == assingedSize;
		else
			return assignedToIsArray == assignedIsArray;
	}

	return false;
}
bool isAssignable(Node* assignedTo, Node* assigned)
{
	Type_enum typeAssignedTo = assignedTo->type;
	Type_enum TypeAssigned = assigned->type;
	bool assignedToIsArray = assignedTo->isArray;
	bool assignedIsArray = assigned->isArray;
	int assignedToSize = assignedTo->arraySize;
	int assingedSize = assigned->arraySize;

	if (typeAssignedTo == OUR_VOID || TypeAssigned == OUR_VOID || typeAssignedTo == TYPE_ERROR || TypeAssigned == TYPE_ERROR)
		return false;

	if (typeAssignedTo == TypeAssigned || (!assignedToIsArray && typeAssignedTo == OUR_INT && TypeAssigned == OUR_BYTE))
	{
		if (assignedToIsArray)
			return assignedToIsArray == assignedIsArray && assignedToSize == assingedSize;
		else
			return assignedToIsArray == assignedIsArray;
	}

	return false;
}