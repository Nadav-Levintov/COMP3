%{
	#include <iostream>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"

	using namespace std;

	stack<Table> tableStack;
	stack<int> offsetStack;

	extern int yylex();
	extern int yylineno;
	int yyerror(char * message);
	void open_new_scope();
	void close_scope();
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOP
%token ID
%token NUM
%token STRING
%token EOF1

%%

Program		: {
				FuncTable f_table;
				list<FormalsDecl> print_formals;
				list<FormalsDecl> printi_formals;
				FormalsDecl print_formal(OUR_STRING, "str");
				FormalsDecl printi_formal(OUR_INT, "i");
				
				print_formals.push_back(print_formal);
				printi_formals.push_back(printi_formal);

				FuncTableEntry print_entry(string("print"), RetType(OUR_VOID), print_formals);
				FuncTableEntry printi_entry(string("printi"), RetType(OUR_VOID), printi_formals);

			
				f_table.push(print_entry);
				f_table.push(printi_entry);
			
				tableStack.push(f_table);
				offsetStack.push(0);
			}	Funcs
			;

Funcs		:
			|	FuncDecl Funcs
			;

		FuncDecl:	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{
				
			}
			;

RetType		:	Type
			|	VOID
			;

Formals		:	{ $$ = new Formals(FormalsList()); }
			|	FormalsList { $$ = new Formals((dynamic_cast<FormalsList*>($1)));}
			;

FormalsList:	FormalsDecl { $$ = new FormalsList();
							  dynamic_cast<FormalsList*>($$)->addFormal(dynamic_cast<FormalsDecl*>($1)); }
			|	FormalsDecl  COMMA FormalsList { $$ = new FormalsList();
												 dynamic_cast<FormalsList*>($$)->addFormal(dynamic_cast<FormalsDecl*>($1));
												 dynamic_cast<FormalsList*>($$)->mergeList(dynamic_cast<FormalsList*>($3)); }
			;

FormalsDecl:	Type ID { $$ = new FormalsDecl($1->type,$2->str_val);}
			|	Type ID LBRACK NUM RBRACK { $$ = new FormalsDecl($1->type,$2->str_val,$4->int_val,true); }
			|	Type ID LBRACK NUM B RBRACK{ $$ = new FormalsDecl($1->type,$2->str_val,$4->int_val,true,true); }
			;

Statements	:	Statement
			|	Statements Statement
			;

Statement	:	LBRACE Statements RBRACE
			|	Type ID SC
			|	Type ID ASSIGN Exp SC
			|	Type ID LBRACK NUM RBRACK SC 
			| 	Type ID LBRACK NUM B RBRACK SC 
			| 	ID ASSIGN Exp SC 
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN SC
			|	RETURN Exp SC
			|	IF LPAREN Exp RPAREN Statement
			|	%prec IF LPAREN Exp RPAREN Statement ELSE Statement
			|	WHILE LPAREN Exp RPAREN Statement 
			|	BREAK SC
			;

Call		:	ID LPAREN ExpList RPAREN
			|	ID LPAREN RPAREN
			;

ExpList		:	Exp
			|	Exp COMMA ExpList
			;

Type		:	INT
			|	BYTE
			|	BOOL
			;

Exp			:	LPAREN	Exp RPAREN
			|	ID LBRACK Exp RBRACK
			|	Exp BINOP Exp
			|	ID
			|	Call
			|	NUM
			|	NUM B
			|	STRING
			|	TRUE
			|	FALSE
			|	Exp	AND	Exp
			|	Exp	OR Exp
			|	Exp	RELOP Exp
			|	NOT	Exp
			;


%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}

void open_new_scope()
{

}

void close_scope() {

}