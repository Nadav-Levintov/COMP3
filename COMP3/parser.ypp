%{
	#include <iostream>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"

	using namespace std;

	stack<Table> tableStack;
	stack<int> offsetStack;

	extern int yylex();
	extern int yylineno;
	int yyerror(char * message);
	void open_new_scope();
	void close_scope();
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOP
%token ID
%token NUM
%token STRING
%token EOF1

%%

Program		: {
				tableStack = new stack<Table>();
				offsetStack = new stack<int>();
				FuncTable f_table = new FuncTable();
			
				f_table.push(new FuncTableEntry("print", OUR_VOID, (new list<FormalsDecl>()).insert(new FormalsDecl(OUR_STRING, "str")));
				f_table.push(new FuncTableEntry("printi", OUR_VOID, (new list<FormalsDecl>()).insert(new FormalsDecl(OUR_INT, "i"))));
			
				tableStack.push(f_table);
				offsetStack.push(0);
			}	Funcs
			;

Funcs		:
			|	FuncDecl Funcs
			;

		FuncDecl:	RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{
				
			}
			;

RetType		:	Type
			|	VOID
			;

Formals		:	  { $$ = new Formals(new FormalsList();); }
				| FormalsList{ $$ = new Formals($1); }
			;

FormalsList:	FormalsDecl { $$ = new FormalsList();
							$$.addFormal($1); }
			|	FormalsDecl  COMMA FormalsList { $$ = new FormalsList();
												 $$.addFormal($1);
												 $$.mergeList($3); }
			;

FormalsDecl:	Type ID { $$ = new FormalsDecl($1.type,$2.str_val);}
			|	Type ID LBRACK NUM RBRACK { $$ = new FormalsDecl($1.type,$2.str_val,$4.int_val,true); }
			|	Type ID LBRACK NUM B RBRACK{ $$ = new FormalsDecl($1.type,$2.str_val,$4.int_val,true,true); }
			;

Statements	:	Statement
			|	Statements Statement
			;

Statement	:	LBRACE Statements RBRACE
			|	Type ID SC
			|	Type ID ASSIGN Exp SC
			|	Type ID LBRACK NUM RBRACK SC 
			| 	Type ID LBRACK NUM B RBRACK SC 
			| 	ID ASSIGN Exp SC 
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC
			|	Call SC
			|	RETURN SC
			|	RETURN Exp SC
			|	IF LPAREN Exp RPAREN Statement
			|	%prec IF LPAREN Exp RPAREN Statement ELSE Statement
			|	WHILE LPAREN Exp RPAREN Statement 
			|	BREAK SC
			;

Call		:	ID LPAREN ExpList RPAREN
			|	ID LPAREN RPAREN
			;

ExpList		:	Exp
			|	Exp COMMA ExpList
			;

Type		:	INT
			|	BYTE
			|	BOOL
			;

Exp			:	LPAREN	Exp RPAREN
			|	ID LBRACK Exp RBRACK
			|	Exp BINOP Exp
			|	ID
			|	Call
			|	NUM
			|	NUM B
			|	STRING
			|	TRUE
			|	FALSE
			|	Exp	AND	Exp
			|	Exp	OR Exp
			|	Exp	RELOP Exp
			|	NOT	Exp
			;


%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}

void open_new_scope()
{

}

void close_scope() {

}