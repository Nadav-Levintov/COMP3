%{
	#include <iostream>
	#include <string>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"

	using namespace std;
	using namespace output;

#define BYTE_MAX_SIZE 255
#define ARRAY_MIN_SIZE 1
#define YYERROR_VERBOSE 1
#define YYDEBUG 1 

	stack<Table*> tableStack;
	FuncTable* funcTable;
	stack<int> offsetStack;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);

	void make_table();
	bool is_break_scope();
	bool check_var_exists_id(string id, Node** retNode);
	void open_new_scope(bool is_break_allowed);
	void open_new_function_scope(Type_enum retType);
	bool check_func_exists(string& id, Node* expListNode, Type_enum **retType);
	void close_scope();
	bool check_func_exists_name(string id);
	bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray, int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize);
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%nonassoc IF
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOP
%token ID
%token NUM
%token STRING
%nonassoc  ELSE

%%

Program		: { make_table(); }	Funcs					{
															if (!check_func_exists_name("main"))
															{
																errorMainMissing();
																exit(0);
															}

															FuncTableEntry* func;

															for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
															{
																if ((*it)->id == "main" )
																{
																	func = (*it);
																	break;
																}
																
															}
															
															if (func->nodeList.size() != 0)
															{
																errorMainMissing();
																exit(0);
															}

															if (OUR_VOID != func->retType)
															{
																errorMainMissing();
																exit(0);
															}

															/*print*/
															endScope();
															tableStack.top()->print_scope();
															tableStack.pop();
															offsetStack.pop();
														}
			;

Funcs		:
			|	FuncDecl Funcs
			;

FuncDecl	:	RetType ID LPAREN Formals RPAREN		{
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															FuncTable *f_table = dynamic_cast<FuncTable*>(tableStack.top());
															Type_enum retType = $1->type;
															FuncTableEntry *func_entry = new FuncTableEntry($2->id, retType, $4->frmlList);
															f_table->push(func_entry);
															open_new_function_scope($1->type);
															int param_offset = 0;
															for (vector<Node*>::iterator it = $4->frmlList.begin();it != $4->frmlList.end(); it++)
															{
																VarTableEntry *var_entry;
																Node* temp;
																Node* frml = (*it);
																if (check_var_exists_id(frml->id, &temp) || check_func_exists_name(frml->id))
																{
																	errorDef(yylineno, frml->id);
																	exit(0);
																}
																if (frml->isArray)
																{
																	param_offset -= frml->arraySize;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																else {
																	param_offset--;
																	var_entry = new VarTableEntry(frml, param_offset);
																	
																}
																dynamic_cast<VarTable*>(tableStack.top())->push(var_entry);

															}
														} LBRACE Statements RBRACE {
															close_scope();
														}
			;

RetType		:	Type									{ $$ = $1; }
			|	VOID									{ $$ = new  Node(OUR_VOID); }
			;

Formals		:											{ $$ = new Node(); }
			|	FormalsList								{ $$ = $1;}
			;

FormalsList:	FormalsDecl								{ 
															$$ = new Node();
															$$->frmlList.push_back($1); }
			|	FormalsDecl  COMMA FormalsList			{	
															$$ = $3;
															$$->frmlList.insert($$->frmlList.begin(),$1); }
			;

FormalsDecl:	Type ID									{ $$ = new Node($2->id, $1->type);}
			|	Type ID LBRACK NUM RBRACK				{
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno,$2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal);
														}
			|	Type ID LBRACK NUM B RBRACK				{ 
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															$$ = new Node($2->id, $1->type, $4->intVal); 
														}
			;

Statements	:	Statement
			|	Statements Statement
			;

Statement	:	LBRACE Mark3 Statements Mark2 RBRACE
			|	Type ID SC								{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
														}
			|	Type ID ASSIGN Exp SC					{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if (!isAssignable($1->type, false , $1->arraySize,$4->type,$4->isArray, $4->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
														}
			|	Type ID LBRACK NUM RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
														}
			| Type ID LBRACK NUM B RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($2->id, &node) || check_func_exists_name($2->id))
															{
																errorDef(yylineno, $2->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $4->id);
																exit(0);
															}
															if ($4->intVal > BYTE_MAX_SIZE || $4->intVal < ARRAY_MIN_SIZE)
															{
																errorInvalidArraySize(yylineno, $2->id);
																exit(0);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
														}
			| ID ASSIGN Exp SC							{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, node->isArray, node->arraySize, $3->type, $3->isArray, $3->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC		{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															if (!isAssignable(node->type, false, node->arraySize, $6->type, $6->isArray , $6->arraySize) || !$3->isNum() || !node->isArray)
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			|	Call SC
			|	RETURN SC								{
															Type_enum scopeRetType = funcTable->get_scope_type();
															if (scopeRetType != OUR_VOID)
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			|	RETURN Exp SC							{
															Type_enum scopeRetType = (tableStack.top())->get_scope_type();
															if (!isAssignable(scopeRetType, false, 0, $2->type, $2->isArray, $2->arraySize))
															{
																errorMismatch(yylineno);
																exit(0);
															}
														}
			| 	IF Mark1 Statement Mark2 ELSE Mark3 Statement Mark2		%prec ELSE
			| 	IF Mark1 Statement Mark2								%prec IF	
			|	WHILE LPAREN Exp RPAREN{
															if (!$3->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															open_new_scope(true);
														} Statement Mark2
			|	BREAK SC								{ 
															if(!is_break_scope() )
															{
																errorUnexpectedBreak(yylineno);
																exit(0);
															}
														}
			;

Mark1		:		LPAREN Exp RPAREN					{
															if (!$2->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															open_new_scope(false);
														} ;

Mark2		:										{
														close_scope();
													};

Mark3		:										{
														open_new_scope(false);
													};


Call		:	ID LPAREN ExpList RPAREN				{ Type_enum *retType;
															if (check_func_exists($1->id,$3, &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno,$1->id);
																exit(0);
															}
														}
			|	ID LPAREN RPAREN						{	Type_enum *retType;
															if(check_func_exists($1->id,new Node(), &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno, $1->id);
																exit(0);
															}
														}
			;

ExpList		:	Exp										{	Node *node = new Node();
															node->expList.push_back($1);
															$$ = node; }
			|	Exp COMMA ExpList						{	Node *l = ($3);
															l->expList.insert(l->expList.begin(),$1);
															$$ = l; }
			;

Type		:	INT										{	$$ = new Node(OUR_INT); }
			|	BYTE									{	$$ = new Node(OUR_BYTE); }
			|	BOOL									{	$$ = new Node(OUR_BOOL); }
			;

Exp			:	LPAREN	Exp RPAREN						{	$$ = $2; }
			|	ID LBRACK Exp RBRACK					{
															if (!($3)->isNum())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
																exit(0);
															}
															$$ = new Node(node);
															$$->isArray = false;
														}
			|	Exp BINOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															if($1->isByte() && $3->isByte())
															{
																$$ = new Node(OUR_BYTE);
															}
															else
															{
																$$ = new Node(OUR_INT);
															}
														}
			|	ID										{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
																{
																	$$ = node;
																}
															else
																{
																	errorUndef(yylineno, $1->id);
																	exit(0);
																}
														}
			|	Call									{	$$ = $1; }
			|	NUM										{	
															$$ = $1;
														}
			|	NUM B									{	
															int val = $1->intVal;
															if (val > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $1->id);
																exit(0);
															}
															$$ = new Node(OUR_BYTE,val); }
			|	STRING									{	$$ = new Node(OUR_STRING); }
			|	TRUE									{	$$ = new Node(OUR_BOOL); }
			|	FALSE									{	$$ = new Node(OUR_BOOL); }
			|	Exp	AND	Exp								{	if(!($1->isBool() && $3->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	Exp	OR Exp								{	if(!($1->isBool() && $3->isBool()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	Exp	RELOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	NOT	Exp									{	if(!($2)->isBool())
															{
																errorMismatch(yylineno);
																exit(0);
															}
															$$ = new Node(OUR_BOOL); }
			;


%%

int main()
{
	//set this to 1 to show more info
#ifdef DEBUG
	yydebug = 1;
#endif
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	if (yydebug)
		cout<<"Parse error: "<<message <<" line:"<<yylineno <<endl;
	exit(0);
}

void open_new_scope(bool is_break_allowed=false)
{
	bool is_current_while = is_break_scope();
	Type_enum retType = tableStack.top()->get_scope_type();
	VarTable *v = new VarTable(is_break_allowed || is_current_while, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void open_new_function_scope(Type_enum retType)
{
	VarTable *v = new VarTable(false, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void close_scope() {
	/*print*/
	endScope();
	tableStack.top()->print_scope();

	tableStack.pop();
	offsetStack.pop();

}

void make_table()
{
	funcTable = new FuncTable();
	vector<Node*> print_formals;
	vector<Node*> printi_formals;
	Node* print_formal = new Node(OUR_STRING);
	Node* printi_formal= new Node(OUR_INT);

	print_formals.push_back(print_formal);
	printi_formals.push_back(printi_formal);

	FuncTableEntry* print_entry = new FuncTableEntry("print", OUR_VOID, print_formals);
	FuncTableEntry* printi_entry= new FuncTableEntry("printi", OUR_VOID, printi_formals);

	funcTable->push(print_entry);
	funcTable->push(printi_entry);

	tableStack.push(funcTable);

	offsetStack.push(0);
}


bool check_var_exists_id(string id, Node** retNode)
{
	if (tableStack.size() <= 1)
		return false;
	
	vector<VarTableEntry*> current_table_rows = (dynamic_cast<VarTable*>(tableStack.top()))->rows;
	for (int i=0; i< current_table_rows.size() ; i++)
	{
		if (current_table_rows[i]->node->id == id)
		{
			*retNode = (current_table_rows[i]->node);
			return true;
		}
	}

	VarTable* temp = dynamic_cast<VarTable*>(tableStack.top());
	tableStack.pop();
	bool res = check_var_exists_id(id, retNode);
	tableStack.push(temp);
	return res;
}

bool check_func_exists(string& id, Node* expListNode, Type_enum **retType)
{
	if (!check_func_exists_name(id))
	{
		return false;
	}

	vector<string> types;
	FuncTableEntry* func;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id )
		{
			func = (*it);
			break;
		}
		
	}

	if (func->nodeList.size() != expListNode->expList.size())
	{
		for (int i = 0; i < func->nodeList.size(); i++)
		{
			if (func->nodeList[i]->isArray)
				types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
			else
				types.push_back(get_type_string(func->nodeList[i]->type));
		}
		//cout << "*******************1" << endl;
		errorPrototypeMismatch(yylineno, id, types);
		exit(0);
	}


		for (int j = 0; j<func->nodeList.size(); j++)
		{
			if (!expListNode->expList[j]->compareType(func->nodeList[j]))
			{
				for (int i = 0; i < func->nodeList.size(); i++)
				{
					if (func->nodeList[i]->isArray)
						types.push_back(makeArrayType(get_type_string(func->nodeList[i]->type), func->nodeList[i]->arraySize));
					else
						types.push_back(get_type_string(func->nodeList[i]->type));
				}
				//cout << "func->nodeList[j] "	  << func->nodeList[j]->type          <<endl;
				//cout << "func->nodeList[j] " << func->nodeList[j]->isArray << endl;
				//cout << "expListNode->expList[j]" << expListNode->expList[j]->type << endl;
				//cout << "expListNode->expList[j]" << expListNode->expList[j]->isArray <<endl;
				//cout << "*******************2" << endl;
				errorPrototypeMismatch(yylineno, id, types);
				exit(0);
			}
		}
		*retType = &func->retType;
		return true;

}

bool check_func_exists_name(string id)
{
	int i = 0;

	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id)
		{
			return true;
		}

	}
	return false;
}

bool is_break_scope()
{
	return tableStack.top()->is_while;
}

bool isAssignable(Type_enum typeAssignedTo, bool assignedToIsArray,int assignedToSize, Type_enum TypeAssigned, bool assignedIsArray, int assingedSize)
{
	if (typeAssignedTo == TypeAssigned || (!assignedToIsArray && typeAssignedTo == OUR_INT && TypeAssigned == OUR_BYTE))
	{
		if (assignedToIsArray)
			return assignedToIsArray == assignedIsArray && assignedToSize == assingedSize;
		else
			return assignedToIsArray == assignedIsArray;
	}

	return false;
}