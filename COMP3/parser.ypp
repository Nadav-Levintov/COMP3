%{
	#include <iostream>
	#include <string>
	#include <stdlib.h>
	#include <stack>
	#include "output.hpp"
	#include "parser.hpp"

	using namespace std;
	using namespace output;

#define BYTE_MAX_SIZE 255
#define YYERROR_VERBOSE 1
#define YYDEBUG 1 

	stack<Table*> tableStack;
	FuncTable* funcTable;
	stack<int> offsetStack;

	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);

	void make_table();
	bool is_break_scope();
	bool check_var_exists_id(string id, Node** retNode);
	void open_new_scope(bool is_break_allowed);
	void open_new_function_scope(Type_enum retType);
	bool check_func_exists(string& id, Node* expListNode, Type_enum **retType);
	void close_scope();
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%left AND
%left OR
%right NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token SC
%token COMMA
%left LPAREN
%left RPAREN
%left LBRACE
%left RBRACE
%left LBRACK
%left RBRACK
%right ASSIGN
%left RELOP
%left BINOP
%token ID
%token NUM
%token STRING
%token EOF1

%%

Program		: { make_table(); }	Funcs					{
															/*print*/
															endScope();
															tableStack.top()->print_scope();
															tableStack.pop();
															offsetStack.pop();
														}
			;

Funcs		:
			|	FuncDecl Funcs
			;

FuncDecl	:	RetType ID LPAREN Formals RPAREN		{
															FuncTable *f_table = dynamic_cast<FuncTable*>(tableStack.top());
															Type_enum retType = $1->type;
															FuncTableEntry *func_entry = new FuncTableEntry($2->id, retType, $4->frmlList);
															f_table->push(func_entry);
															open_new_scope(false);
															int param_offset = -1;
															for (vector<Node*>::iterator it = $4->frmlList.begin();it != $4->frmlList.end(); it++)
															{
																VarTableEntry *var_entry;
																Node* frml = (*it);
																if (frml->isArray)
																{
																	var_entry = new VarTableEntry(frml, param_offset);
																	param_offset-= frml->arraySize;
																}
																else {
																	var_entry = new VarTableEntry(frml, param_offset);
																	param_offset--;
																}
																dynamic_cast<VarTable*>(tableStack.top())->push(var_entry);

															}
														} LBRACE Statements RBRACE {
															close_scope();
														}
			;

RetType		:	Type									{ $$ = $1; }
			|	VOID									{ $$ = new  Node(OUR_VOID); }
			;

Formals		:											{ $$ = new Node(); }
			|	FormalsList								{ $$ = $1;}
			;

FormalsList:	FormalsDecl								{ 
															$$ = new Node();
															$$->frmlList.push_back($1); }
			|	FormalsDecl  COMMA FormalsList			{	
															$$ = $3;
															$$->frmlList.insert($$->frmlList.begin(),$1); }
			;

FormalsDecl:	Type ID									{ $$ = new Node($2->id, $1->type);}
			|	Type ID LBRACK NUM RBRACK				{ $$ = new Node($2->id, $1->type, $4->intVal); }
			|	Type ID LBRACK NUM B RBRACK				{ 
															if($4->intVal > BYTE_MAX_SIZE)
																errorByteTooLarge(yylineno,$4->id);
															$$ = new Node($2->id, $1->type, $4->intVal); 
														}
			;

Statements	:	Statement
			|	Statements Statement
			;

Statement	:	LBRACE Statements RBRACE		
			|	Type ID SC								{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
															{
																errorDef(yylineno, $1->id);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
														}
			|	Type ID ASSIGN Exp SC					{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
															{
																errorDef(yylineno, $1->id);
															}
															if (!$4->compareType($1))
															{
																errorMismatch(yylineno);
															}
															Node* newNode = new Node($2->id, $1->type);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() ++;
														}
			|	Type ID LBRACK NUM RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
															{
																errorDef(yylineno, $1->id);
															}
															if ($4->intVal > BYTE_MAX_SIZE)
															{
																errorInvalidArraySize(yylineno, $4->id);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
														}
			| Type ID LBRACK NUM B RBRACK SC			{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
															{
																errorDef(yylineno, $1->id);
															}
															if ($4->intVal > BYTE_MAX_SIZE) 
															{
																errorByteTooLarge(yylineno, $4->id);
															}
															Node* newNode = new Node($2->id, $1->type, $4->intVal);
															VarTableEntry *entry = new VarTableEntry(newNode, offsetStack.top());
															dynamic_cast<VarTable*>(tableStack.top())->push(entry);
															offsetStack.top() += ($4)->intVal;
														}
			| ID ASSIGN Exp SC							{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
															}
															if (!node->compareType($3)) 
															{
																errorMismatch(yylineno);
															}
														}
			|	ID LBRACK Exp RBRACK ASSIGN Exp SC		{
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
															}
															if (node->type != $6->type || !$3->isNum() || !node->isArray)
															{
																errorMismatch(yylineno);
															}
														}
			|	Call SC
			|	RETURN SC								{
															Type_enum scopeRetType = funcTable->get_scope_type();
															if (scopeRetType != OUR_VOID)
																errorMismatch(yylineno);
														}
			|	RETURN Exp SC							{
															Type_enum scopeRetType = funcTable->get_scope_type();
															if (scopeRetType != $2->type)
																errorMismatch(yylineno);
														}
			|	IF LPAREN Exp RPAREN					{
															if (!$3->isBool())
																errorMismatch(yylineno);
															open_new_scope(false);
														} Statement{
															close_scope();
														}
			|	%prec IF LPAREN Exp RPAREN				{
															if (!$3->isBool())
																errorMismatch(yylineno);
															open_new_scope(false);
														} Statement {
															close_scope();
														} ELSE {
															open_new_scope(false);
														} Statement {
															close_scope();
														}
			|	WHILE LPAREN Exp RPAREN					{
															if(!$3->isBool())
																errorMismatch(yylineno);
															open_new_scope(true);
														} Statement	{
																close_scope();
														}
			|	BREAK SC									{ 
																if(!is_break_scope() )
																	errorUnexpectedBreak(yylineno);
															}
			;

Call		:	ID LPAREN ExpList RPAREN				{ Type_enum *retType;
															if (check_func_exists($1->id,$3, &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno,$1->id);
															}
														}
			|	ID LPAREN RPAREN						{	Type_enum *retType;
															if(check_func_exists($1->id,new Node(), &retType))
															{
																$$->type = *retType;
															}
															else
															{
																errorUndefFunc(yylineno, $1->id);
															}
														}
			;

ExpList		:	Exp										{	Node *node = new Node();
															node->expList.push_back($1);
															$$ = node; }
			|	Exp COMMA ExpList						{	Node *l = ($3);
															l->expList.insert(l->expList.begin(),$1);
															$$ = l; }
			;

Type		:	INT										{	$$ = new Node(OUR_INT); }
			|	BYTE									{	$$ = new Node(OUR_BYTE); }
			|	BOOL									{	$$ = new Node(OUR_BOOL); }
			;

Exp			:	LPAREN	Exp RPAREN						{	$$ = $2; }
			|	ID LBRACK Exp RBRACK					{
															if (!($3)->isNum())
															{
																errorMismatch(yylineno);
															}
															Node* node;
															if (!check_var_exists_id($1->id, &node))
															{
																errorUndef(yylineno, $1->id);
															}
															$$ = node;
														}
			|	Exp BINOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
															}
															if($1->isByte() && $3->isByte())
															{
																$$ = new Node(OUR_BYTE);
															}
															else
															{
																$$ = new Node(OUR_INT);
															}
														}
			|	ID										{	
															Node* node;
															if (check_var_exists_id($1->id, &node))
																{
																	$$ = node;
																}
															else
																{
																	errorUndef(yylineno, $1->id);
																}
														}
			|	Call									{	$$ = $1; }
			|	NUM										{	
															$$ = $1;
														}
			|	NUM B									{	
															int val = $1->intVal;
															if (val > BYTE_MAX_SIZE)
															{
																errorByteTooLarge(yylineno, $1->id);
															}
															$$ = new Node(OUR_BYTE,val); }
			|	STRING									{	$$ = new Node(OUR_STRING); }
			|	TRUE									{	$$ = new Node(OUR_BOOL); }
			|	FALSE									{	$$ = new Node(OUR_BOOL); }
			|	Exp	AND	Exp								{	if(!($1->isBool() && $3->isBool()))
															{
																errorMismatch(yylineno);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	Exp	OR Exp								{	if(!($1->isBool() && $3->isBool()))
															{
																errorMismatch(yylineno);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	Exp	RELOP Exp							{	if(!($1->isNum() && $3->isNum()))
															{
																errorMismatch(yylineno);
															}
															$$ = new Node(OUR_BOOL);
														}
			|	NOT	Exp									{	if(!($2)->isBool())
															{
																errorMismatch(yylineno);
															}
															$$ = new Node(OUR_BOOL); }
			;


%%

int main()
{
	//yydebug = 1;
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message <<endl;
	exit(0);
}

void open_new_scope(bool is_break_allowed=false)
{
	bool is_current_while = is_break_scope();
	Type_enum retType = tableStack.top()->get_scope_type();
	VarTable *v = new VarTable(is_break_allowed || is_current_while, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void open_new_function_scope(Type_enum retType)
{
	VarTable *v = new VarTable(false, retType);
	tableStack.push(v);
	offsetStack.push(offsetStack.top());
}

void close_scope() {
	/*print*/
	endScope();
	tableStack.top()->print_scope();

	tableStack.pop();
	offsetStack.pop();

}

void make_table()
{
	funcTable = new FuncTable();
	vector<Node*> print_formals;
	vector<Node*> printi_formals;
	Node* print_formal = new Node(OUR_STRING);
	Node* printi_formal= new Node(OUR_INT);

	print_formals.push_back(print_formal);
	printi_formals.push_back(printi_formal);

	FuncTableEntry* print_entry = new FuncTableEntry("print", OUR_VOID, print_formals);
	FuncTableEntry* printi_entry= new FuncTableEntry("printi", OUR_VOID, printi_formals);

	funcTable->push(print_entry);
	funcTable->push(printi_entry);

	tableStack.push(funcTable);

	offsetStack.push(0);
}


bool check_var_exists_id(string id, Node** retNode)
{
	if (tableStack.size() <= 1)
		return false;
	
	vector<VarTableEntry*> current_table_rows = (dynamic_cast<VarTable*>(tableStack.top()))->rows;
	//for(vector<VarTableEntry*>::iterator it = current_table_rows.begin(); it != current_table_rows.end();it++)
	for (int i=0; i< current_table_rows.size() ; i++)
	{
		if (current_table_rows[i]->node->id == id)
		{
			*retNode = (current_table_rows[i]->node);
			return true;
		}
	}

	VarTable* temp = dynamic_cast<VarTable*>(tableStack.top());
	tableStack.pop();
	bool res = check_var_exists_id(id, retNode);
	tableStack.push(temp);
	return res;
}

bool check_func_exists(string& id, Node* expListNode, Type_enum **retType)
{
	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id && (*it)->nodeList.size() == expListNode->expList.size())
		{
			for(int j=0;j<(*it)->nodeList.size();j++)
			{
				if (!expListNode->expList[j]->compareType((*it)->nodeList[j]))
				{
					return false;
				}
			}
			*retType = &(*it)->retType;
			return true;
		}
		
	}
	return false;
}

bool check_func_exists_name(string& id)
{
	int i = 0;
	for (vector<FuncTableEntry*>::iterator it = funcTable->rows.begin(); it != funcTable->rows.end(); it++)
	{
		if ((*it)->id == id)
		{
			return true;
		}

	}
	return false;
}

bool is_break_scope()
{
	return tableStack.top()->is_while;
}